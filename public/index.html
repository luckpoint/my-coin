<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prize DApp - Admin/Child Mode</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8f9fa; }
        .container { max-width: 960px; }
        .card, .section-box { border-radius: 0.75rem; box-shadow: 0 0.25rem 0.75rem rgba(0,0,0,0.075); }
        .btn { border-radius: 0.375rem; }
        .navbar { border-bottom: 1px solid #dee2e6; }
        .product-img-placeholder {
            width: 100%;
            height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            overflow: hidden;
        }
        .product-img-placeholder img {
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
        }
        .section-box { background-color: #ffffff; padding: 2rem; margin-bottom: 2rem; }
        .navbar-brand strong { font-weight: 700; }
        .admin-mode-panel h3 { color: #0dcaf0; } /* Token Admin Panel Title */
        .child-mode-panel h3 { color: #198754; } /* Child Claim Panel Title */
        .shop-admin-panel h3 { color: #fd7e14; } /* Shop Admin Panel Title */
        .mode-switch-btn.active { font-weight: bold; }
        .icon-admin { margin-right: 0.3em; vertical-align: text-bottom;}
        .icon-child { margin-right: 0.3em; vertical-align: text-bottom;}
        .icon-shield { margin-right: 0.3em; vertical-align: text-bottom;}

    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-white mb-3">
        <div class="container">
            <a class="navbar-brand" href="#">>Prize DApp</a>
            <button id="connectWalletBtn" class="btn btn-primary">Connect Wallet</button>
        </div>
    </nav>

    <div class="container mt-3 mb-4">
        <div class="btn-group w-100" role="group" aria-label="Mode Switch">
            <button type="button" class="btn btn-outline-primary mode-switch-btn" data-mode="admin" id="adminModeBtn" style="display:none;">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill-gear icon-admin" viewBox="0 0 16 16">
                  <path d="M11 5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm-9 8c0 1 1 1 1 1h5.256A4.493 4.493 0 0 1 8 12.5a4.49 4.49 0 0 1 1.544-3.393C9.077 9.038 8.564 9 8 9c-5 0-6 3-6 4Zm9.886-3.54c.18-.613 1.048-.613 1.229 0l.043.148a.64.64 0 0 0 .921.382l.136-.074c.561-.306 1.175.308.87.869l-.075.136a.64.64 0 0 0 .382.92l.149.045c.612.18.612 1.048 0 1.229l-.15.043a.64.64 0 0 0-.38.921l.074.136c.305.561-.309 1.175-.87.87l-.136-.075a.64.64 0 0 0-.92.382l-.045.149c-.18.612-1.048.612-1.229 0l-.043-.15a.64.64 0 0 0-.921-.38l-.136.074c-.561.305-1.175-.309-.87-.87l.075-.136a.64.64 0 0 0-.382-.92l-.148-.045c-.613-.18-.613-1.048 0-1.229l.148-.043a.64.64 0 0 0 .382-.921l-.074-.136c-.306-.561.308-1.175.869-.87l.136.075a.64.64 0 0 0 .92-.382l.045-.148ZM14 12.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0Z"/>
                </svg>
                Admin Mode
            </button>
            <button type="button" class="btn btn-outline-success mode-switch-btn active" data-mode="child">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-arms-up icon-child" viewBox="0 0 16 16">
                  <path d="M8 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/>
                  <path d="m5.93 6.704-.846 8.451L4.043 15l-2.437-1.526.234-2.341L.533 9.5l2.64-1.65L4 6.453l.002-.002.313-1.037a.5.5 0 0 1 .963-.062l.359 1.076-.004.004ZM10.07 6.704l.846 8.451L11.957 15l2.437-1.526-.234-2.341L15.467 9.5l-2.64-1.65L12 6.453l-.002-.002-.313-1.037a.5.5 0 0 0-.963-.062l-.359 1.076.004.004Z"/>
                </svg>
                Child Mode
            </button>
        </div>
    </div>

    <div class="container">
        <div id="walletInfo" class="mb-4 p-3 bg-light border rounded" style="display: none;">
            <p class="mb-1"><strong>Network:</strong> <span id="networkName">-</span></p>
            <p class="mb-0"><strong>Account:</strong> <span id="accountAddress">-</span> (<span id="accountRoleToken">General</span><span id="accountRoleShopSeparator" style="display:none;">, </span><span id="accountRoleShop" style="display:none;"></span>)</p>
        </div>

        <div id="notificationArea"></div>

        <section id="adminModeContent" class="section-box admin-mode-panel" style="display: none;">
            <h3>
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-person-fill-gear icon-admin" viewBox="0 0 16 16">
                  <path d="M11 5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm-9 8c0 1 1 1 1 1h5.256A4.493 4.493 0 0 1 8 12.5a4.49 4.49 0 0 1 1.544-3.393C9.077 9.038 8.564 9 8 9c-5 0-6 3-6 4Zm9.886-3.54c.18-.613 1.048-.613 1.229 0l.043.148a.64.64 0 0 0 .921.382l.136-.074c.561-.306 1.175.308.87.869l-.075.136a.64.64 0 0 0 .382.92l.149.045c.612.18.612 1.048 0 1.229l-.15.043a.64.64 0 0 0-.38.921l.074.136c.305.561-.309 1.175-.87.87l-.136-.075a.64.64 0 0 0-.92.382l-.045.149c-.18.612-1.048.612-1.229 0l-.043-.15a.64.64 0 0 0-.921-.38l-.136.074c-.561.305-1.175-.309-.87-.87l.075-.136a.64.64 0 0 0-.382-.92l-.148-.045c-.613-.18-.613-1.048 0-1.229l.148-.043a.64.64 0 0 0 .382-.921l-.074-.136c-.306-.561.308-1.175.869-.87l.136.075a.64.64 0 0 0 .92-.382l.045-.148ZM14 12.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0Z"/>
                </svg>
                Admin Mode (Token Operations)
            </h3>
            <form id="setPendingTokensForm">
                <div class="mb-3">
                    <label for="childAddressInput" class="form-label">Child's Ethereum Address</label>
                    <input type="text" class="form-control" id="childAddressInput" placeholder="0x..." required>
                </div>
                <p>Prepare to grant <strong>100 <span id="tokenAdminSymbol">MTK</span></strong> coins to the child at the address above.</p>
                <button type="submit" class="btn btn-primary">Prepare 100 Coin Grant</button>
            </form>
            <hr>
            <div id="shopAdminPanelContainer" style="display:none;">
                 <div class="mt-4 shop-admin-panel">
                    <h3>
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-shield icon-shield"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>
                        Shop Product Management
                    </h3>
                    <div>
                        <h4>Update Existing Product Price</h4>
                        <form id="updatePriceForm">
                            <div class="mb-3"><label for="updateProductId" class="form-label">Product ID</label><input type="number" class="form-control" id="updateProductId" min="0" required></div>
                            <div class="mb-3"><label for="updateProductNewPrice" class="form-label">New Price (in <span id="shopAdminTokenSymbol2">MTK</span>)</label><input type="number" class="form-control" id="updateProductNewPrice" step="0.01" min="0.01" required></div>
                            <button type="submit" class="btn btn-info">Update Price</button>
                        </form>
                    </div>
                </div>
            </div>
        </section>

        <section id="childModeContent" class="section-box child-mode-panel" style="display: none;">
            <h3>
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-person-arms-up icon-child" viewBox="0 0 16 16">
                  <path d="M8 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/>
                  <path d="m5.93 6.704-.846 8.451L4.043 15l-2.437-1.526.234-2.341L.533 9.5l2.64-1.65L4 6.453l.002-.002.313-1.037a.5.5 0 0 1 .963-.062l.359 1.076-.004.004ZM10.07 6.704l.846 8.451L11.957 15l2.437-1.526-.234-2.341L15.467 9.5l-2.64-1.65L12 6.453l-.002-.002-.313-1.037a.5.5 0 0 0-.963-.062l-.359 1.076.004.004Z"/>
                </svg>
                Child Mode
            </h3>
            
            <div class="card mb-4">
                <div class="card-header">Coin Information</div>
                <div class="card-body">
                    <p>Your Balance: <strong id="tokenBalanceChild">0</strong> <span id="childTokenSymbolBalance">MTK</span></p>
                    <p>Pending coins you can receive: <strong id="myPendingTokensAmountSpan">0</strong> <span id="childTokenSymbolPending">MTK</span></p>
                    <button id="claimMyTokensBtn" class="btn btn-success mb-2" disabled>Claim Pending Coins</button>
                    <button id="faucetBtnChild" class="btn btn-info" disabled>Get 100 <span id="childTokenSymbolFaucet">MTK</span> from Faucet</button>
                </div>
            </div>

            <h4>Prize Exchange</h4>
            <div id="productListChild" class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-4">
                </div>
        </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module">
        import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.min.js";

        // --- Smart Contract Settings (Important: Replace with your own) ---
        const MY_TOKEN_ADDRESS = "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853";
        const MY_TOKEN_ABI = [ 
            "constructor(string name, string symbol, uint256 initialSupplyToOwner)",
            "event Approval(address indexed owner, address indexed spender, uint256 value)",
            "event FaucetFunded(address indexed funder, uint256 amount)",
            "event FaucetTokensTaken(address indexed recipient, uint256 amount)",
            "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
            "event TokensClaimedByChild(address indexed child, uint256 amountClaimed)",
            "event TokensPendingForChild(address indexed child, uint256 amountPrepared, uint256 newTotalPending)",
            "event Transfer(address indexed from, address indexed to, uint256 value)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function balanceOf(address account) view returns (uint256)",
            "function claimMyTokens() external",
            "function decimals() view returns (uint8)",
            "function faucet() external",
            "function fundFaucetSupply(uint256 amount) external",
            "function getMyPendingTokens() view returns (uint256)",
            "function name() view returns (string)",
            "function owner() view returns (address)",
            "function pendingTokensForChild(address) view returns (uint256)",
            "function renounceOwnership() external",
            "function setPendingTokens(address child, uint256 amount) external",
            "function symbol() view returns (string)",
            "function totalSupply() view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function transferFrom(address from, address to, uint256 amount) returns (bool)",
            "function transferOwnership(address newOwner) external"
        ];

        const SHOP_CONTRACT_ADDRESS = "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6";
        const SHOP_ABI = [ /* Shop.sol ABI based on contract content */
            "constructor(address tokenAddress)",
            "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
            "event ProductAdded(uint256 id, string name, uint256 price)",
            "event ProductPurchased(address indexed buyer, uint256 indexed productId, uint256 price)",
            "event ProductPriceUpdated(uint256 indexed productId, uint256 newPrice)",
            "event TokensWithdrawn(address indexed owner, uint256 amount)",
            "function addProduct(string _name, uint256 _price) external",
            "function getProduct(uint256 _productId) view returns (uint256 id, string name, uint256 price, bool isActive)",
            "function nextProductId() view returns (uint256)",
            "function owner() view returns (address)",
            "function products(uint256) view returns (uint256 id, string name, uint256 price, bool isActive)",
            "function purchaseProduct(uint256 _productId) external",
            "function renounceOwnership() external",
            "function token() view returns (address)",
            "function transferOwnership(address newOwner) external",
            "function updateProductPrice(uint256 _productId, uint256 _newPrice) external",
            "function withdrawTokens() external"
        ];
        // --- End Smart Contract Settings ---

        let provider, signer, myTokenContract, shopContract, userAddress;
        let tokenDecimals = 18;
        let isShopAdmin = false;
        let isTokenAdmin = false;
        let currentMode = 'child'; // Default mode

        let productsMetadata = {};

        // DOM elements
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        const walletInfoDiv = document.getElementById('walletInfo');
        const networkNameSpan = document.getElementById('networkName');
        const accountAddressSpan = document.getElementById('accountAddress');
        const accountRoleShopSpan = document.getElementById('accountRoleShop');
        const accountRoleShopSeparatorSpan = document.getElementById('accountRoleShopSeparator');
        const accountRoleTokenSpan = document.getElementById('accountRoleToken');
        
        const tokenSymbolSpan = document.getElementById('tokenSymbol'); // Generic, might be removed if not used globally
        // const tokenSymbolDisplaySpan = document.getElementById('tokenSymbolDisplay'); // Used in old faucet
        // const faucetTokenSymbolSpan = document.getElementById('faucetTokenSymbol'); // Used in old faucet
        // const tokenBalanceSpan = document.getElementById('tokenBalance'); // Used in old faucet
        // const faucetBtn = document.getElementById('faucetBtn'); // Old faucet button

        const notificationArea = document.getElementById('notificationArea');
        
        // Mode Switch UI
        const modeSwitchButtons = document.querySelectorAll('.mode-switch-btn');
        const adminModeBtn = document.getElementById('adminModeBtn');
        const adminModeContentDiv = document.getElementById('adminModeContent');
        const childModeContentDiv = document.getElementById('childModeContent');

        // Admin Mode (Token) UI
        const setPendingTokensForm = document.getElementById('setPendingTokensForm');
        const childAddressInput = document.getElementById('childAddressInput');
        // const childAmountInput = document.getElementById('childAmountInput'); // Removed, fixed to 100
        const tokenAdminSymbolSpan = document.getElementById('tokenAdminSymbol');

        // Admin Mode (Shop - within Admin Mode Content)
        const shopAdminPanelContainer = document.getElementById('shopAdminPanelContainer');
        const updatePriceForm = document.getElementById('updatePriceForm');
        const shopAdminTokenSymbol1Span = document.getElementById('shopAdminTokenSymbol1');
        const shopAdminTokenSymbol2Span = document.getElementById('shopAdminTokenSymbol2');


        // Child Mode UI
        const tokenBalanceChildSpan = document.getElementById('tokenBalanceChild');
        const childTokenSymbolBalanceSpan = document.getElementById('childTokenSymbolBalance');
        const myPendingTokensAmountSpan = document.getElementById('myPendingTokensAmountSpan');
        const childTokenSymbolPendingSpan = document.getElementById('childTokenSymbolPending');
        const claimMyTokensBtn = document.getElementById('claimMyTokensBtn');
        const faucetBtnChild = document.getElementById('faucetBtnChild');
        const childTokenSymbolFaucetSpan = document.getElementById('childTokenSymbolFaucet');
        const productListChildDiv = document.getElementById('productListChild');


        window.addEventListener('load', async () => {
            connectWalletBtn.addEventListener('click', handleConnectDisconnectToggle);
            
            setPendingTokensForm.addEventListener('submit', handleSetPendingTokens); // Token Admin
            claimMyTokensBtn.addEventListener('click', handleClaimMyTokens); // Child Claim
            faucetBtnChild.addEventListener('click', handleFaucet); // Child Faucet

            updatePriceForm.addEventListener('submit', handleUpdatePrice); 

            modeSwitchButtons.forEach(button => {
                button.addEventListener('click', () => switchMode(button.dataset.mode));
            });
            
            loadMetadataFromLocalStorage();

            if (typeof window.ethereum !== 'undefined') {
                window.ethereum.on('accountsChanged', handleAccountsChanged);
                window.ethereum.on('chainChanged', (_chainId) => window.location.reload());
            }
            switchMode(currentMode); // Initialize with default mode
            // await renderProducts(); // Render products for child mode initially if needed
        });

        function switchMode(newMode) {
            if (!signer && (newMode === 'admin')) {
                 showNotification("Admin mode is available after wallet connection.", "warning");
                 return; // Admin mode requires wallet connection
            }
            currentMode = newMode;
            console.log("Switched to mode:", currentMode);
            updateUIVisibility();

            modeSwitchButtons.forEach(btn => {
                if (btn.dataset.mode === newMode) {
                    btn.classList.add('active');
                    // btn.classList.add('btn-' + getModeColor(newMode)); // Color change can be complex with outlines
                    // btn.classList.remove('btn-outline-' + getModeColor(newMode));
                } else {
                    btn.classList.remove('active');
                    // btn.classList.remove('btn-' + getModeColor(btn.dataset.mode));
                    // btn.classList.add('btn-outline-' + getModeColor(btn.dataset.mode));
                }
            });
            
            if (signer) { // Only if wallet is connected
                if (currentMode === 'child') {
                    displayMyPendingTokens();
                    renderProductsForChild(); // Render products for child
                    updateChildTokenBalance(); // Update balance in child mode
                } else if (currentMode === 'admin') {
                    // Admin mode specific initializations if any
                }
            }
        }

        function updateUIVisibility() {
            adminModeContentDiv.style.display = currentMode === 'admin' && isTokenAdmin ? 'block' : 'none';
            childModeContentDiv.style.display = currentMode === 'child' ? 'block' : 'none';
            
            adminModeBtn.style.display = isTokenAdmin ? 'inline-block' : 'none';
            shopAdminPanelContainer.style.display = currentMode === 'admin' && isShopAdmin ? 'block' : 'none';

            // If current mode is admin but user is not token admin, switch to child
            if (currentMode === 'admin' && !isTokenAdmin && signer) { // Added signer check
                switchMode('child');
            }

            // Control Faucet Button visibility and state
            if (signer && isTokenAdmin) {
                faucetBtnChild.style.display = 'inline-block';
                faucetBtnChild.disabled = false;
            } else {
                faucetBtnChild.style.display = 'none';
                faucetBtnChild.disabled = true; 
            }
            
            // Handle UI elements based on wallet connection and roles
            if (!signer) {
                // Wallet not connected: Child mode is shown by default, but interactive elements are disabled/modified
                childModeContentDiv.style.display = 'block'; 
                adminModeContentDiv.style.display = 'none';
                adminModeBtn.style.display = 'none'; 
                shopAdminPanelContainer.style.display = 'none';
                
                claimMyTokensBtn.disabled = true;
                claimMyTokensBtn.style.display = 'inline-block'; // Visible (as child panel is shown) but disabled
                myPendingTokensAmountSpan.textContent = "Wallet not connected";
                // Faucet button is already hidden and disabled by the block above.
            } else {
                // Wallet is connected:
                
                // Claim My Tokens Button:
                if (currentMode === 'child' && !isTokenAdmin) {
                    claimMyTokensBtn.style.display = 'inline-block'; 
                    // claimMyTokensBtn.disabled state is managed by displayMyPendingTokens()
                } else {
                    claimMyTokensBtn.style.display = 'none'; // Hide for admin, or if not in child mode
                }

                // Faucet button state is handled by (signer && isTokenAdmin) block earlier.
                // Other updates (balance, pending tokens for child) are handled in initializeUserSession/switchMode
            }
        }
        
        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                resetApp();
            } else if (accounts[0].toLowerCase() !== userAddress) {
                userAddress = accounts[0].toLowerCase();
                // Re-initialize session without forcing a switch to child mode immediately.
                // Let currentMode dictate behavior, and initializeUserSession will update based on that.
                initializeUserSession();
            }
        }
        
        async function initializeUserSession() {
            if (!signer || !userAddress) return;
            updateWalletInfoDisplay();
            await checkShopAdminRole(); // For shop product management
            await checkTokenAdminRole(); // For token distribution
            updateUIVisibility(); 
            if (myTokenContract) {
                await getTokenInfo(); // This sets tokenDecimals

                // Remove any existing listener first to prevent duplicates
                myTokenContract.removeAllListeners("TokensPendingForChild");

                // Add the new listener for when tokens are prepared for the child
                myTokenContract.on("TokensPendingForChild", (child, amountPrepared, newTotalPending, eventContext) => {
                    // Ensure userAddress and tokenDecimals are accessible and current from the closure
                    if (child.toLowerCase() === userAddress.toLowerCase()) {
                        const oneHundredTokensInWei = ethers.parseUnits("100", tokenDecimals);
                        if (amountPrepared === oneHundredTokensInWei) {
                            const amountFormatted = ethers.formatUnits(amountPrepared, tokenDecimals);
                            const symbol = childTokenSymbolPendingSpan.textContent || "tokens"; // Use dynamic symbol
                            console.log(`Event: Admin prepared ${amountFormatted} ${symbol} for you to claim.`);
                            showNotification(`An admin has prepared ${amountFormatted} ${symbol} for you to claim!`, "info", false); // Don't auto-dismiss
                            displayMyPendingTokens(); // Refresh UI for pending tokens
                        }
                    }
                });
                
                if (currentMode === 'child') {
                    await updateChildTokenBalance();
                    await displayMyPendingTokens();
                    await renderProductsForChild();
                }
            }

            if (shopContract) {
                // Remove any existing listener first to prevent duplicates
                shopContract.removeAllListeners("ProductPriceUpdated");

                // Add listener for product price updates
                shopContract.on("ProductPriceUpdated", (productId, newPrice, eventContext) => {
                    console.log(`Event: Product ID ${productId} price updated to ${ethers.formatUnits(newPrice, tokenDecimals)}.`);
                    showNotification(`Price updated for a product! Refreshing list...`, "info");
                    if (currentMode === 'child') {
                        renderProductsForChild(); // Refresh product list for child
                    }
                });
            }
        }

        function resetApp() {
            walletInfoDiv.style.display = 'none';
            accountAddressSpan.textContent = '-';
            networkNameSpan.textContent = '-';
            accountRoleTokenSpan.textContent = 'General';
            accountRoleShopSpan.style.display = 'none';
            accountRoleShopSeparatorSpan.style.display = 'none';
            
            connectWalletBtn.textContent = 'Connect Wallet';
            connectWalletBtn.disabled = false;

            if (myTokenContract) { // If contract instance existed, remove listeners
                myTokenContract.removeAllListeners("TokensPendingForChild");
            }
            if (shopContract) { // If shop contract instance existed, remove listeners
                shopContract.removeAllListeners("ProductPriceUpdated");
            }
            
            provider = null; signer = null; myTokenContract = null; shopContract = null;
            userAddress = null; isShopAdmin = false; isTokenAdmin = false;
            
            currentMode = 'child'; // Reset to child mode
            updateUIVisibility();
            // Clear dynamic content
            myPendingTokensAmountSpan.textContent = "0";
            tokenBalanceChildSpan.textContent = "0";
            productListChildDiv.innerHTML = '<p class="text-muted">Loading products...</p>';
        }

        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                showNotification('MetaMask is not installed.', 'danger'); return;
            }
            try {
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
                userAddress = signer.address.toLowerCase();

                myTokenContract = new ethers.Contract(MY_TOKEN_ADDRESS, MY_TOKEN_ABI, signer);
                shopContract = new ethers.Contract(SHOP_CONTRACT_ADDRESS, SHOP_ABI, signer);
                
                // Diagnostic: Check if Shop contract's token address matches frontend's MY_TOKEN_ADDRESS
                if (shopContract && typeof shopContract.token === 'function') {
                    try {
                        const configuredShopTokenAddress = await shopContract.token();
                        console.log(`Shop contract's configured token address: ${configuredShopTokenAddress}`);
                        console.log(`Frontend's MY_TOKEN_ADDRESS: ${MY_TOKEN_ADDRESS}`);
                        if (configuredShopTokenAddress.toLowerCase() !== MY_TOKEN_ADDRESS.toLowerCase()) {
                            const errorMessage = `CRITICAL MISMATCH: Shop contract token address (${configuredShopTokenAddress}) does not match frontend token address (${MY_TOKEN_ADDRESS}). Purchases will likely fail due to allowance issues.`;
                            console.error(errorMessage);
                            showNotification(errorMessage, "danger", false);
                        } else {
                            console.log("Shop contract token address matches frontend configuration. Allowance issue might have a different origin.");
                        }
                    } catch (e) {
                        console.error("Error fetching shop's configured token address:", e);
                        showNotification("Could not verify Shop's token address. This might indicate a potential configuration issue.", "warning", false);
                    }
                }

                showNotification('Connected to wallet!', 'success');
                connectWalletBtn.textContent = 'Disconnect Wallet'; // Changed from 'Connected'
                connectWalletBtn.disabled = false; // Ensure it's enabled to allow disconnect
                // faucetBtnChild.disabled = false; // This will be handled by updateUIVisibility via initializeUserSession

                await initializeUserSession();

            } catch (error) {
                console.error("Wallet connection error:", error);
                showNotificationError(error, "Wallet connection error");
                resetApp();
            }
        }
        
        async function checkShopAdminRole() {
            if (!shopContract || !userAddress) { isShopAdmin = false; return; }
            try {
                const owner = (await shopContract.owner()).toLowerCase();
                isShopAdmin = (owner === userAddress);
                accountRoleShopSpan.textContent = isShopAdmin ? 'Shop Admin' : '';
                accountRoleShopSpan.style.display = isShopAdmin ? 'inline' : 'none';
                accountRoleShopSeparatorSpan.style.display = isShopAdmin && isTokenAdmin ? 'inline' : 'none';
            } catch (error) {
                console.error("Shop admin role check error:", error); isShopAdmin = false;
                accountRoleShopSpan.style.display = 'none';
                accountRoleShopSeparatorSpan.style.display = 'none';
            }
        }
        async function checkTokenAdminRole() {
            if (!myTokenContract || !userAddress) { isTokenAdmin = false; return; }
            try {
                const owner = (await myTokenContract.owner()).toLowerCase();
                isTokenAdmin = (owner === userAddress);
                accountRoleTokenSpan.textContent = isTokenAdmin ? 'Token Admin' : 'General';
                 accountRoleShopSeparatorSpan.style.display = isShopAdmin && isTokenAdmin ? 'inline' : 'none';
            } catch (error) {
                console.error("Token admin role check error:", error); isTokenAdmin = false;
                accountRoleTokenSpan.textContent = 'General (Check Failed)';
            }
        }

        function updateWalletInfoDisplay() {
            if (!provider || !userAddress) return;
            provider.getNetwork().then(network => {
                if (network.chainId === 31337n) { // Hardhat's default chainId
                    networkNameSpan.textContent = "Hardhat Localhost";
                } else {
                    networkNameSpan.textContent = network.name;
                }
            });
            accountAddressSpan.textContent = userAddress;
            walletInfoDiv.style.display = 'block';
        }

        async function getTokenInfo() {
            if (!myTokenContract) return;
            try {
                const symbol = await myTokenContract.symbol();
                const decimalsResult = await myTokenContract.decimals();
                tokenDecimals = Number(decimalsResult);
                
                // Update all relevant symbol spans
                const symbolSpans = [
                    tokenAdminSymbolSpan, childTokenSymbolBalanceSpan, 
                    childTokenSymbolPendingSpan, childTokenSymbolFaucetSpan,
                    shopAdminTokenSymbol1Span, shopAdminTokenSymbol2Span
                ];
                symbolSpans.forEach(span => { if(span) span.textContent = symbol; });

            } catch (error) {
                console.error("Error getting token info:", error);
                // Fallback for all symbols
                 const symbolSpans = [
                    tokenAdminSymbolSpan, childTokenSymbolBalanceSpan, 
                    childTokenSymbolPendingSpan, childTokenSymbolFaucetSpan,
                    shopAdminTokenSymbol1Span, shopAdminTokenSymbol2Span
                ];
                symbolSpans.forEach(span => { if(span) span.textContent = "MTK"; });
            }
        }
        
        // --- Token Admin Mode Functions ---
        async function handleSetPendingTokens(event) {
            event.preventDefault();
            if (!myTokenContract || !signer || !isTokenAdmin) {
                showNotification("No token admin rights or wallet not connected.", "warning"); return;
            }

            const childAddr = childAddressInput.value;
            const fixedAmountStr = "100"; // Fixed amount

            if (!ethers.isAddress(childAddr)) {
                showNotification("Please enter a valid child address.", "warning"); return;
            }
            
            const amountInWei = ethers.parseUnits(fixedAmountStr, tokenDecimals);
            const submitButton = setPendingTokensForm.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Preparing...';

            try {
                showNotification(`Preparing to grant ${fixedAmountStr} ${tokenAdminSymbolSpan.textContent} to address ${childAddr.substring(0,6)}...`, "info", false);
                const tx = await myTokenContract.setPendingTokens(childAddr, amountInWei);
                await tx.wait();
                showNotification(`Preparation of 100 coin grant complete. Child user can claim from "Child Mode".`, "success");
                setPendingTokensForm.reset(); // Reset only child address input
                childAddressInput.value = ''; // Clear the input specifically
            } catch (error) {
                console.error("Error preparing coin grant:", error);
                showNotificationError(error, "Error preparing coin grant");
            } finally {
                submitButton.disabled = false;
                submitButton.innerHTML = 'Prepare 100 Coin Grant';
            }
        }

        // --- Child Mode Functions ---
        async function updateChildTokenBalance() {
            if (!myTokenContract || !userAddress) {
                tokenBalanceChildSpan.textContent = "Wallet not connected";
                return;
            }
            try {
                const balance = await myTokenContract.balanceOf(userAddress);
                tokenBalanceChildSpan.textContent = ethers.formatUnits(balance, tokenDecimals);
            } catch (error) {
                console.error("Error getting child mode balance:", error);
                tokenBalanceChildSpan.textContent = "Error";
            }
        }

        async function displayMyPendingTokens() {
            if (!myTokenContract || !signer) {
                myPendingTokensAmountSpan.textContent = "Wallet not connected";
                claimMyTokensBtn.disabled = true;
                return;
            }
            try {
                const pendingAmountWei = await myTokenContract.getMyPendingTokens();
                const pendingAmountFormatted = ethers.formatUnits(pendingAmountWei, tokenDecimals);
                myPendingTokensAmountSpan.textContent = pendingAmountFormatted;
                claimMyTokensBtn.disabled = (pendingAmountWei === 0n);
            } catch (error) {
                console.error("Error getting pending token amount:", error);
                myPendingTokensAmountSpan.textContent = "Error fetching";
                claimMyTokensBtn.disabled = true;
                showNotificationError(error, "Error getting pending token amount");
            }
        }

        async function handleClaimMyTokens() {
            if (!myTokenContract || !signer) {
                showNotification("Wallet not connected.", "warning"); return;
            }
            
            claimMyTokensBtn.disabled = true;
            claimMyTokensBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Claiming...';

            try {
                showNotification("Claiming pending coins...", "info", false);
                const tx = await myTokenContract.claimMyTokens();
                await tx.wait();
                showNotification("Coins claimed! Check your balance.", "success");
                await updateChildTokenBalance(); 
                await displayMyPendingTokens(); 
            } catch (error) {
                console.error("Error claiming coins:", error);
                showNotificationError(error, "Error claiming coins");
                await displayMyPendingTokens(); // Re-fetch pending tokens on error
            } finally {
                claimMyTokensBtn.innerHTML = 'Claim Pending Coins';
                // Disabled state will be re-evaluated by displayMyPendingTokens
            }
        }
        
        async function handleFaucet() { // This is now faucetBtnChild
            if (!myTokenContract || !signer) { showNotification("Wallet not connected.", "warning"); return; }
            showNotification("Getting 100 coins from Faucet...", "info", false);
            faucetBtnChild.disabled = true;
            try {
                const tx = await myTokenContract.faucet(); // Assumes faucet gives 100 tokens
                await tx.wait();
                showNotification("Got 100 coins from Faucet!", "success");
                await updateChildTokenBalance();
            } catch (error) {
                console.error("Faucet error:", error);
                showNotificationError(error, "Faucet processing error");
            } finally {
                faucetBtnChild.disabled = false;
            }
        }

        async function renderProductsForChild() {
            let displayContract = shopContract;
            // If shopContract is not initialized but provider is, create a read-only instance
            if (!displayContract && provider) {
                try {
                    displayContract = new ethers.Contract(SHOP_CONTRACT_ADDRESS, SHOP_ABI, provider);
                } catch (e) { 
                    productListChildDiv.innerHTML = '<p class="text-danger">Failed to load Shop contract.</p>'; return;
                }
            } else if (!displayContract) { // If provider also not available
                 productListChildDiv.innerHTML = '<p class="text-muted">Failed to load product list (contract not connected).</p>'; return;
            }

            productListChildDiv.innerHTML = '<div class="d-flex justify-content-center mt-3"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading products...</span></div></div>';
            
            const availableImages = ['images/image1.png', 'images/image2.png'];

            try {
                const nextIdBN = await displayContract.nextProductId(); // Changed from getProductCount
                const productCount = Number(nextIdBN); // nextProductId gives the count of products (0 to count-1)
                
                if (productCount === 0) {
                    productListChildDiv.innerHTML = '<p class="text-muted">No products currently for sale.</p>';
                    return;
                }

                productListChildDiv.innerHTML = ''; // Clear loading
                let displayedCount = 0;
                for (let i = 0; i < productCount; i++) { // 'i' will be the productId
                    const productInfo = await displayContract.getProduct(i);
                    // productInfo should be { id: BigInt, name: string, price: BigInt, isActive: bool }
                    const priceBN = productInfo.price;
                    const onChainName = productInfo.name;
                    const isActiveOnChain = productInfo.isActive;

                    const metadata = productsMetadata[i] || {}; // 'i' is the productId
                    const displayName = metadata.name || onChainName; // Prefer local name, fallback to on-chain
                    // const imagePlaceholder = metadata.imagePlaceholder || 'Product Image'; // Default if not in metadata
                    const productImageSrc = availableImages[i % availableImages.length]; // Cycle through available images

                    if (isActiveOnChain && priceBN > 0n) { // Use on-chain isActive status
                        displayedCount++;
                        const priceString = ethers.formatUnits(priceBN, tokenDecimals);
                        const productCard = `
                            <div class="col">
                                <div class="card h-100 product-card">
                                    <div class="product-img-placeholder">
                                        <img src="${productImageSrc}" alt="${displayName}">
                                    </div>
                                    <div class="card-body d-flex flex-column">
                                        <h5 class="card-title">${displayName}</h5>
                                        <p class="card-text mt-auto">Price: <strong>${priceString} ${childTokenSymbolBalanceSpan.textContent || 'MTK'}</strong></p>
                                        <button class="btn btn-primary w-100 mt-2 purchase-btn-child" data-product-id="${i}" data-price-wei="${priceBN.toString()}" ${!signer ? 'disabled' : ''}>
                                            Purchase
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                        productListChildDiv.insertAdjacentHTML('beforeend', productCard);
                    }
                }
                if(displayedCount === 0) {
                     productListChildDiv.innerHTML = '<p class="text-muted">No products available for purchase at the moment.</p>';
                }

                document.querySelectorAll('.purchase-btn-child').forEach(button => {
                    button.addEventListener('click', handlePurchaseChild);
                });

            } catch (error) {
                console.error("Child mode product list error:", error);
                showNotificationError(error, "Product list retrieval error");
                productListChildDiv.innerHTML = '<p class="text-danger">An error occurred while loading the product list.</p>';
            }
        }
        
        async function handlePurchaseChild(event) {
            if (!shopContract || !myTokenContract || !signer) { 
                showNotification("Wallet not connected.", "warning"); return;
            }

            const productId = event.target.dataset.productId;
            const priceWei = BigInt(event.target.dataset.priceWei);

            const purchaseButton = event.target;
            purchaseButton.disabled = true;
            purchaseButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Checking...';

            try {
                // 1. Check balance before attempting transaction
                const balanceWei = await myTokenContract.balanceOf(userAddress);
                if (balanceWei < priceWei) {
                    showNotification("Insufficient funds to purchase this item.", "warning");
                    purchaseButton.disabled = false;
                    purchaseButton.innerHTML = 'Purchase';
                    return;
                }

                purchaseButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Approving...';
                showNotification(`Approving token usage for Shop contract...`, "info", false);
                const approveTx = await myTokenContract.approve(SHOP_CONTRACT_ADDRESS, priceWei);
                await approveTx.wait();
                showNotification("Token usage approval (Approve) complete.", "success", true); // Auto dismiss success

                purchaseButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Purchasing...';
                showNotification(`Processing purchase for Product ID ${productId}...`, "info", false);
                const purchaseTx = await shopContract.purchaseProduct(productId);
                await purchaseTx.wait();

                showNotification(`Purchase of Product ID ${productId} complete!`, "success");
                await updateChildTokenBalance(); 
                // Optionally re-render products if stock changes, for now not needed

                // Update button to "Purchased" and keep it disabled
                purchaseButton.innerHTML = 'Purchased';
                purchaseButton.disabled = true; // Already disabled, but good to be explicit
            } catch (error) {
                console.error("Child mode purchase error:", error);
                // Try to get a more specific reason
                let friendlyMessage = "Purchase processing error.";
                if (error.reason) {
                    friendlyMessage = `Purchase failed: ${error.reason}`;
                } else if (error.data && error.data.message) {
                    friendlyMessage = `Purchase failed: ${error.data.message}`;
                } else if (error.message && error.message.includes("insufficient funds")) {
                    friendlyMessage = "Purchase failed: Insufficient funds for the transaction.";
                }
                showNotificationError(error, friendlyMessage); // Show the detailed error for devs but a friendlier one too
            } finally {
                // Ensure button state is managed correctly, if not purchased, re-enable
                if (purchaseButton.innerHTML !== 'Purchased') {
                    purchaseButton.disabled = false;
                    purchaseButton.innerHTML = 'Purchase';
                }
            }
        }
        
        // --- Shop Admin Functions (called from Admin Mode) ---
        async function handleUpdatePrice(event) { 
            event.preventDefault(); 
            if (!shopContract || !signer || !isShopAdmin) { 
                showNotification("No shop admin rights or wallet not connected.", "warning"); return;
            }
            const id = document.getElementById('updateProductId').value;
            const priceStr = document.getElementById('updateProductNewPrice').value;

            if (id === "" || !priceStr) { showNotification("Product ID and new price are required.", "warning"); return; }
            
            const priceWei = ethers.parseUnits(priceStr, tokenDecimals);
            const btn = updatePriceForm.querySelector('button[type="submit"]'); 
            btn.disabled = true; btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Updating...';
            
            try {
                const tx = await shopContract.updateProductPrice(id, priceWei); 
                await tx.wait();
                showNotification(`Price for Product ID ${id} updated.`, "success");
                updatePriceForm.reset(); 
                if (currentMode === 'child') await renderProductsForChild();
            } catch (e) { 
                showNotificationError(e, "Price update error"); 
            } finally { 
                btn.disabled = false; btn.innerHTML = 'Update Price'; 
            }
        }

        // --- Utility Functions ---
        function showNotification(message, type = 'info', autoDismiss = true) {
            const existingAlert = notificationArea.querySelector(`.alert.alert-${type}.fade.show`); // More specific selector
            if (existingAlert && autoDismiss) { 
                const bsAlertInstance = bootstrap.Alert.getInstance(existingAlert);
                if (bsAlertInstance) bsAlertInstance.close();
            }
            
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show mt-3`;
            alertDiv.role = 'alert';
            alertDiv.innerHTML = `${message} <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>`;
            notificationArea.prepend(alertDiv);

            if (autoDismiss) {
                setTimeout(() => {
                    const currentBsAlert = bootstrap.Alert.getOrCreateInstance(alertDiv);
                    if (currentBsAlert) currentBsAlert.close();
                }, 5000);
            }
        }
        function showNotificationError(error, contextMessage = "Error") {
            let detail = error.reason || (error.data && error.data.message) || error.message || 'Unknown error';
            // Clean up common revert prefixes
            detail = detail.replace(/^execution reverted: /i, '');
            detail = detail.replace(/^VM Exception while processing transaction: reverted with reason string '/i, '').replace(/'$/, '');
            detail = detail.replace(/^Error: Transaction reverted without a reason string/i, 'Transaction reverted without a reason string');


            showNotification(`${contextMessage}: ${detail}`, "danger", false); // Errors do not auto-dismiss
        }
        function saveMetadataToLocalStorage() { try { localStorage.setItem('productsMetadata', JSON.stringify(productsMetadata)); } catch (e) { console.warn("Failed to save metadata to local storage:", e); }}
        function loadMetadataFromLocalStorage() { try { const s = localStorage.getItem('productsMetadata'); if (s) productsMetadata = JSON.parse(s); } catch (e) { console.warn("Failed to load metadata from local storage:", e); productsMetadata = {}; }}

        // --- New handler function and disconnect function ---
        function handleConnectDisconnectToggle() {
            if (signer) { // If wallet is connected (signer exists)
                disconnectWallet();
            } else { // If wallet is not connected
                connectWallet();
            }
        }

        function disconnectWallet() {
            if (provider && provider.provider && typeof provider.provider.disconnect === 'function') {
                // For some providers like WalletConnect, you might need to explicitly call disconnect.
                // For MetaMask, this is usually not necessary as `resetApp` handles the state.
                // provider.provider.disconnect(); // Uncomment if using a provider that requires this.
            }
            resetApp(); // Resets signer, provider, UI elements, etc.
            showNotification("Wallet disconnected.", "info");
            // resetApp ensures the button text is "Connect Wallet" and it's enabled.
        }
        // --- End New handler function and disconnect function ---

    </script>
</body>
</html>
