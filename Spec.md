## アプリケーション設計案

### 1. 概要

* **アプリケーション名:** (例) TokenShop DApp
* **目的:** ERC-20トークンを取得し、そのトークンを使用して（架空の）実物資産商品と交換するプロセスを体験する学習用ウェブアプリケーション。
* **主要機能:**
    1.  Ethereumウォレット (MetaMask) との接続。
    2.  スマートコントラクトからの独自ERC-20トークンの取得 (Faucet機能)。
    3.  独自トークン残高の表示。
    4.  商品リストの表示（商品名、価格）。
    5.  独自トークンを使用した商品の購入処理。
* **ターゲットユーザー:** ブロックチェーンおよびDApp開発初学者。

### 2. システムアーキテクチャ

* **フロントエンド:**
    * **フレームワーク/ライブラリ:** Bootstrap 5 (UIデザイン), JavaScript (ロジック)
    * **Ethereum連携:** ether.js
    * **役割:** ユーザーインターフェースの提供、ウォレットとの連携、スマートコントラクトの読み取りと書き込み操作の実行。
* **スマートコントラクト (Ethereum上):**
    * **言語:** Solidity
    * **コントラクト1: `MyToken.sol` (ERC-20準拠トークン)**
        * 独自トークンの発行、管理。
        * Faucet機能（ユーザーがテスト用トークンを取得できる）。
    * **コントラクト2: `Shop.sol` (商品交換コントラクト)**
        * 商品のリスト（簡易的なもの）。
        * トークンでの商品購入処理。
* **ブロックチェーンネットワーク:**
    * 開発・テスト時はローカル環境 (Ganache, Hardhat Networkなど) を推奨。
    * 将来的にはテストネット (Sepolia, Goerliなど) にデプロイ可能。
* **バックエンド:**
    * 学習用のため、**原則不要**。商品情報はスマートコントラクトまたはフロントエンドにハードコードします。実物資産の発送管理や詳細な注文管理はスコープ外とします。

### 3. フロントエンド設計 (Bootstrap, ether.js)

* **画面構成 (シングルページアプリケーションを想定):**
    * **ヘッダー:**
        * アプリケーション名
        * ウォレット接続/切断ボタン
        * 接続中のアカウントアドレス表示
        * 現在のネットワーク表示
    * **メインコンテンツ:**
        * **セクション1: トークン管理**
            * トークン名、シンボル表示
            * 自分のトークン残高表示
            * 「トークンを取得する」ボタン (Faucet機能呼び出し)
        * **セクション2: 商品リスト**
            * 各商品をカード形式で表示 (Bootstrap Cardコンポーネント利用)
                * 商品画像 (ダミー画像で可)
                * 商品名
                * 価格 (独自トークン建て)
                * 「購入する」ボタン
        * **セクション3: トランザクション情報**
            * 実行したトランザクションのステータス（例: 承認待ち、成功、失敗）を簡易表示
* **主要なJavaScript (ether.js) 機能:**
    * **ウォレット連携 (`wallet.js` などにモジュール化):**
        * MetaMaskなどのプロバイダの検出。
        * アカウントへの接続要求 (`provider.send("eth_requestAccounts", [])`)。
        * 署名者 (Signer) の取得 (`provider.getSigner()`)。
        * ネットワーク変更、アカウント変更のイベントリスナー設定。
    * **ERC-20トークン操作 (`myTokenService.js` など):**
        * `MyToken.sol` のABIとコントラクトアドレスを保持。
        * `ethers.Contract` を使用してコントラクトインスタンスを作成。
        * 残高取得: `contract.balanceOf(userAddress)`。
        * Faucet機能呼び出し: `contract.connect(signer).faucet()` (仮の関数名)。
    * **商品購入操作 (`shopService.js` など):**
        * `Shop.sol` のABIとコントラクトアドレスを保持。
        * `ethers.Contract` を使用してコントラクトインスタンスを作成。
        * 商品リスト取得 (もしコントラクトから取得する場合): `contract.getProducts()` (仮の関数名)。
        * 購入処理:
            1.  トークン利用許可: `myTokenContract.connect(signer).approve(shopContractAddress, price)`。
            2.  商品購入: `shopContract.connect(signer).purchaseProduct(productId)` (仮の関数名)。
    * **UI更新:**
        * 取得した情報 (残高、商品リストなど) をHTMLに反映。
        * トランザクションの進捗に応じてユーザーにフィードバック。

### 4. スマートコントラクト設計 (Solidity)

#### 4.1. `MyToken.sol` (ERC-20準拠トークン)


#### 4.2. `Shop.sol` (商品交換コントラクト)


### 5. 主要なユーザーストーリー/フロー

役割:
*   **管理者 (親):** トークンを子供に配布する役割。商品の購入はできない。
*   **子供:** 管理者からトークンを受け取り、商品を購入する役割。

1.  **共通: ユーザー (管理者または子供) がウォレットを接続する:**
    *   アプリを開く → 「ウォレット接続」ボタンをクリック → MetaMaskが起動し接続を要求 → ユーザーが承認 → アカウントアドレスとネットワークがアプリに表示される。
    *   アプリは接続されたアカウントが管理者か子供かを識別する（識別方法は別途定義。例: コントラクトに登録されたアドレスリスト）。

2.  **管理者: 子供アカウントにトークンを送付する:**
    *   管理者としてウォレットを接続。
    *   トークン管理画面（または専用の送付画面）で、送付先の子供のウォレットアドレスと送付するトークン量を入力。
    *   「送付する」ボタンをクリック。
    *   MetaMaskがトークン送付トランザクション（`MyToken.sol` の `transfer` 関数を想定）の承認を要求。
    *   管理者が承認 → トランザクションが成功。
    *   子供のトークン残高が増加し、管理者のトークン残高が減少する。アプリ上で確認できる。

3.  **子供: トークン残高を確認する:**
    *   子供としてウォレットを接続。
    *   トークン管理画面で自分のトークン残高を確認。管理者から送付されたトークンが反映されていることを確認する。
    *   (備考: 従来のFaucet機能は廃止、または管理者のみが初期トークンをMintし子供に配布する形に変更)

4.  **子供: 商品を購入する:**
    *   子供としてウォレットを接続。
    *   「商品リスト」から欲しい商品を選ぶ → 「購入する」ボタンをクリック。
    *   **Step 1: Approve (初回または上限不足時):**
        *   アプリがShopコントラクトに必要な額のトークン使用許可（`MyToken.sol` の `approve` 関数）を促す。
        *   MetaMaskが `approve` トランザクションの承認を要求 → 子供が承認 → トランザクション成功。
    *   **Step 2: Purchase:**
        *   （Approve後）アプリが `Shop.sol` の `purchaseProduct` 関数（子供専用の購入関数を想定）を呼び出す。
        *   MetaMaskが `purchaseProduct` トランザクションの承認を要求 → 子供が承認 → トランザクション成功。
        *   子供のトークン残高が減少し、Shopコントラクトのトークン残高が増加（またはバーンされる）。
        *   アプリに「購入処理が完了しました」などのメッセージを表示。
        *   （実世界の処理として）オフチェーンシステムが `ProductPurchased` イベントを監視し、商品の発送準備を開始する（この部分はアプリのスコープ外）。

5.  **管理者: 商品リストの閲覧 (購入不可):**
    *   管理者としてウォレットを接続。
    *   商品リストを閲覧できるが、「購入する」ボタンは非表示または無効化されている。
    *   `Shop.sol` の購入関数は子供からの呼び出しのみを許可する制御（例: `modifier onlyChild`）が実装されている。

### 6. 開発ステップの提案

1.  **環境構築:** Node.js, npm/yarn, Hardhat/Truffle (スマートコントラクト開発用) をインストール。
2.  **スマートコントラクト開発:** `MyToken.sol` と `Shop.sol` を作成・コンパイルし、ローカルネットワーク (例: Hardhat Network) にデプロイ。
3.  **フロントエンド基礎構築:** HTMLで基本的なレイアウトをBootstrapで作成。
4.  **ウォレット接続機能実装:** ether.jsを使ってMetaMaskとの接続機能を実装。
5.  **トークン取得機能実装:** デプロイした`MyToken`コントラクトのFaucet機能を呼び出すUIとロジックを実装。残高表示も実装。
6.  **商品表示機能実装:** `Shop.sol` から（またはハードコードで）商品情報を取得し、表示するUIを実装。
7.  **商品購入機能実装:** `approve`と`purchaseProduct`を呼び出すUIとロジックを実装。トランザクションのフィードバック表示も実装。
8.  **テストとデバッグ:** 各機能をテストし、問題を修正。

### 7. 考慮事項（学習用として）

* **エラーハンドリング:** ether.jsの呼び出しやトランザクションの失敗など、基本的なエラーハンドリングを実装する（例: `try...catch`、ユーザーへの通知）。
* **セキュリティ:** 学習用なので高度なセキュリティ対策（リエントランシーガードの詳細な実装など）は簡略化しますが、`approve`の仕組みや`transferFrom`の動作は正しく理解することが重要です。
* **ガス代:** ローカルやテストネットではあまり気になりませんが、実際のメインネットではガス代最適化も重要になることを意識しておくと良いでしょう。
* **UI/UX:** Bootstrapで基本的な見た目は整いますが、ユーザーが操作しやすいように、状態変化（ローディング中、成功、失敗など）を明確に伝えることが大切です。
